<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon/favicon_black.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon/favicon_black.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon/favicon_black.png">
  <link rel="mask-icon" href="/images/favicon/favicon_black.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"sylvesterkwon.github.io","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Computer Science &#x2F; Problem Solving &#x2F; Competitive Programming">
<meta property="og:type" content="website">
<meta property="og:title" content="ASIX&#39; AXIS">
<meta property="og:url" content="https://sylvesterkwon.github.io/index.html">
<meta property="og:site_name" content="ASIX&#39; AXIS">
<meta property="og:description" content="Computer Science &#x2F; Problem Solving &#x2F; Competitive Programming">
<meta property="og:locale" content="ko_KR">
<meta property="article:author" content="Dohyun Kwon">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://sylvesterkwon.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'ko'
  };
</script>

  <title>ASIX' AXIS</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-169818997-3"></script>
    <script>
      if (CONFIG.hostname === location.hostname) {
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'UA-169818997-3');
      }
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">ASIX' AXIS</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Dohyun Kwon's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>홈</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-e-maxx-kor">

    <a href="/e-maxx-kor/" rel="section"><i class="fa fa-book fa-fw"></i>e-maxx-kor</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/ps-220104/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/ps-220104/" class="post-title-link" itemprop="url">Problem solving (2022/01/04)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2022-01-04 13:59:30 / Updated at: 15:58:37" itemprop="dateCreated datePublished" datetime="2022-01-04T13:59:30+09:00">2022-01-04</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>오랫동안 손대지 않았던 PS를 다시 단련하기 시작했다. 내가 생각하는 PS의 가장 중요한, “생각하는 재미” 가 있는 문제들을 찾아 AtCoder Regular Contest (ARC) 기출 문제를 몇가지 풀었다. 그 중 재밌었던 몇가지 문제의 풀이를 소개한다. </p>
<h2 id="Camels-and-Bridge-ARC105C"><a href="#Camels-and-Bridge-ARC105C" class="headerlink" title="Camels and Bridge (ARC105C)"></a><a href="https://atcoder.jp/contests/arc105/tasks/arc105_c" target="_blank" rel="noopener">Camels and Bridge (ARC105C)</a></h2><p>우선 다리가 붕괴되는 케이스를 예외처리하는데, 다리에서 capacity 가 가장 적은 부분을 무게가 가장 무거운 낙타가 혼자 통과하지 못하는 경우가 유일한 경우이다. 이 경우를 제외한다면, 낙타가 일렬로 다리를 통과하는 것이 가능하고 생각할 수 있다. 이 것을 보이는 것은 쉬운데, 낙타 한마리가 다리를 다 건너기 전까지 다른 낙타를 출발시키지 않는다고 생각하면 된다.</p>
<p>다리를 지나는 낙타의 순서를 순열로 나타내면, 순열의 길이는 $2 \leq N \leq 8$ 이고 이는 충분히 작기 때문에 해당 길이의 모든 순열 ($N!$ 개)을 완전탐색 하고, 각 순서에 대한 “첫번째 낙타와 마지막 낙타의 거리의 최소값” 중 최소값이 답이 된다. </p>
<p>그렇다면 낙타가 다리를 지나는 순서가 고정되었다고 가정하고 문제를 풀어보자. $1 \leq i &lt; j \leq n$ 일 때, $i$ 번째 낙타와 $j$ 번째 낙타가 가져야하는 “최소” 간격을 $dp_{i, j}$ 에 저장한다. 사실 “최소”라는 표현은 애매모호함을 넘어 매우 잘못된 표현인데. 정확히는 다음을 의미한다: $i$ 번째 낙타와 $j$ 번째 낙타가 연이어 다리에 들어갈 때, 낙타들이 동시에 올라가지 못하도록 병목이 발생하는 다리 구간들 중 길이가 최대인 한 구간의 길이. 이해가 어렵다면 다음 문단을 읽어보자.</p>
<p>$dp_{i,j}$ 를 빠르게 계산하기 위해 다음과 같은 전처리를 수행한다: 다리 ($i$ 번째 다리의 부분은 $w_i$ 의 무게를 가지고 $l_i$의 길이를 가짐)를 무게순으로 정렬한 후 길이는 누적 최대 길이로 변경한다 (정렬 후, $w_i = \max_{1 \leq j \leq i} w_j$). 이를 사용하면 $dp_{i, j}$ 는 $O(log M)$ 에 계산할 수 있다. 결국 $dp_{1, n} 가 이 문제의 부분해가 되고, 이를 구하기 위해서는 Floyd-Warshall 비스무리한 DP를 해야한다: </p>
<script type="math/tex; mode=display">dp_{1, i} = \max_ {1 \leq j \leq i} dp_{1, j} + dp_{j, i}</script><p>마지막 DP는 $O(N^2)$ 의 수행시간을 가지며, 따라서 최종 시간복잡도는 $O(N!*N^2 log M)$ 이다.</p>
<h2 id="Let’s-Play-Nim-ARC105D"><a href="#Let’s-Play-Nim-ARC105D" class="headerlink" title="Let’s Play Nim (ARC105D)"></a><a href="https://atcoder.jp/contests/arc105/tasks/arc105_d" target="_blank" rel="noopener">Let’s Play Nim (ARC105D)</a></h2><p>기본 nim game의 필승 전략을 알고 있다면 Sprague-Grundy 정리 따위는 잊어버리고 그리디한 필승전략을 생각해보자. 우선 문제에서 소개되어 있는 1번 행동을 두명이서 번갈아 가면서 $N$ 번 수행하면 그 다음부터는 2번 행동, 즉, 우리가 잘 알고 있는 nim game을 하게 된다. 따라서 $N$ 의 홀짝성에 따라 두 사람의 전략이 바뀐다는 것을 떠올릴 수 있어야 한다. 우선 다음과 같은 케이스로 분류된다:</p>
<ol>
<li>$N$ 이 짝수일 때: 게임을 먼저 시작한 플레이어가 nim game 도 먼저 시작하게 된다. 따라서 선공은 XOR 합이 0이 아니도록, 후공은 XOR 합이 0이 되도록 동전을 접시에 놓아야 한다. 같은 개수의 동전이 든 가방이 모두 짝수개라면, 후공이 반드시 승리한다. 선공이 하는 행동을 그대로 따라하기만 하면 반드시 XOR 합을 0으로 만들 수 있다. 그러나 그 반대의 경우는 선공이 무조건 승리하는데, 선공이 동전이 많이든 가방 순으로 같은 접시에만 동전을 둔다면 과반수 이상의 동전이 한 접시에만 담기게 되고 XOR 합은 0이 될 수 없다.</li>
<li>$N$ 이 홀수일 때: 게임을 나중에 시작한 플레이어가 nim game 을 먼저 시작하게 된다. 이 경우는 반드시 후공의 승리가 보장되어 있다. 후공은 XOR 합이 0이 아니게 두면 되는데, $N$이 짝수인 케이스와 비슷하게 후공은 같은 접시에 최대한 많은 동전을 모으면 반드시 승리한다. 그리고 이 케이스에서는 선공이 후공의 행동에 대칭적으로 플레이할 수도 없다.</li>
</ol>
<p>Nim game 에 대해 알고 싶다면 다음을 참고 하면 좋다: <a href="https://librewiki.net/wiki/%ED%95%84%EC%8A%B9_%EC%A0%84%EB%9E%B5_%EA%B2%8C%EC%9E%84#NIM_.EA.B2.8C.EC.9E.84" target="_blank" rel="noopener">필승 전략 게임</a></p>
<h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p>각 문제당 최소 3시간을 투자했는데, 결국 스스로의 힘으로 해결하지 못했다. 난이도가 1800~2000 인 문제들인데, 아직 내가 스스로 해결할 만한 수준이 아닌 것 같아 아직 갈길이 한참 멀었음을 다시 한번 깨닫게 되었다…</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/USACO%202021%20January%20Contest%20(Silver)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/USACO%202021%20January%20Contest%20(Silver)/" class="post-title-link" itemprop="url">USACO 2021 January Contest (Silver)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2021-04-27 18:29:30 / Updated at: 18:30:51" itemprop="dateCreated datePublished" datetime="2021-04-27T18:29:30+09:00">2021-04-27</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Dance-Mooves"><a href="#Dance-Mooves" class="headerlink" title="Dance Mooves"></a>Dance Mooves</h2><p><a href="https://www.acmicpc.net/problem/20970" target="_blank" rel="noopener">BOJ#20970</a></p>
<p>line에서의 각 위치들을 정점집합으로 가지고, 처음에 $u$에 위치해있던 cow가 $k$분이 지난 후 $v$에 있을 때, 정점 $u$에서 $v$로 가는 간선들의 집합을 가지는 그래프를 만들자. 그래프의 모든 정점의 in-degree와 out-degree가 1이라는 특성을 이용하면, 해당 그래프는 독립된 cycle(loop 포함)들로만 이루어져있음을 알 수 있다.</p>
<p>$k$분까지, 각 cow별로 자리했던 unique한 위치를 set 배열등을 사용해 저장해놓고, 이후 각 cycle마다 set등을 이용하여 지나왔던 unique한 정점의 개수를 세주면 된다. set의 배열과 같은 다소 무거울 수 있는(?) 자료구조를 사용할 수 있는 이유는, set에 들어갈 수 있는 element의 수가 크게 많지 않음이 보장되기 때문이다. (swap으로 인해 발생할 수 있는 $2K$, 기존에 위치했던 자리인 $N$)</p>
<h2 id="No-Time-to-Paint"><a href="#No-Time-to-Paint" class="headerlink" title="No Time to Paint"></a>No Time to Paint</h2><p><a href="https://www.acmicpc.net/problem/20971" target="_blank" rel="noopener">BOJ#20971</a></p>
<p>$[1,x]$에 대한 stroke 최소 횟수를 $pre(x)$라고 하고, $[x,N]$에 대한 stroke 최소 횟수를 $post(x)$라고 하면, query로 주어진 구간 $[s,e]$에 대하여, $pre(s-1)+post(e+1)$를 해주면 답을 구해낼 수 있다.</p>
<p>$pre(), post()$는 monotonic stack을 활용하여 $O(N)$에 전처리 할 수 있다. monotonic stack에 대해 알고싶으면 아래 링크를 참조.</p>
<p>참고하면 좋은 글</p>
<ul>
<li><a href="https://www.acmicpc.net/blog/view/12" target="_blank" rel="noopener">Largest Rectangle in a Histogram 문제에서 monotonic stack을 활용하는 방법</a></li>
</ul>
<h2 id="Spaced-Out"><a href="#Spaced-Out" class="headerlink" title="Spaced Out"></a>Spaced Out</h2><p><a href="https://www.acmicpc.net/problem/20972" target="_blank" rel="noopener">BOJ#20972</a></p>
<p>직접 유효한 cow의 위치를 선정하다보면, 규칙을 발견할 수 있다.</p>
<ul>
<li>어떤 행과 열에서도 이웃된 칸에 cow를 배치하지 않는다면, 해당 case에 대한 total beauty에 대한 계산은 자명하다. (체스판을 생각해보자)</li>
<li>어떤 행에서 이웃한 두 칸에 cow를 배치하면, 배치된 칸이 포함하는 열 전체의 배치는 자동으로 정해진다.</li>
<li>어떤 열의 배치가 확정되었으면, 이웃 열의 배치도 확정된다.</li>
</ul>
<p>이해가 되지 않는다면, 아래 case에서 나머지 cow를 직접 배치해보자. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">?????</span><br><span class="line">?????</span><br><span class="line">?CC??</span><br><span class="line">?????</span><br><span class="line">?????</span><br></pre></td></tr></table></figure>
<p>위와 같은 규칙을 이용하여 가로와 세로로 각각 total beauty를 구하고, 최댓값을 출력하면 된다.</p>
<h2 id="총평"><a href="#총평" class="headerlink" title="총평"></a>총평</h2><p>아마 처음으로 solution을 참고하지 않고 스스로 다 해결한 USACO 셋인것 같다. 이번 contest가 쉬워서 그런 것도 있겠지만, USACO문제들을 처음 풀기 시작한 때에 비하면 실력이 조금 늘긴 늘었나보다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/Convex-hull/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Convex-hull/" class="post-title-link" itemprop="url">Convex Hull 구현</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2021-03-30 14:21:00 / Updated at: 14:22:45" itemprop="dateCreated datePublished" datetime="2021-03-30T14:21:00+09:00">2021-03-30</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>전처리</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">complex</span>&lt;ll&gt; P;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> X real()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Y imag()</span></span><br></pre></td></tr></table></figure>
<p>위껍질 아래껍질 분할 (x축 우선정렬)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n; <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; pt;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">	ll x,y; <span class="built_in">cin</span>&gt;&gt;x&gt;&gt;y;</span><br><span class="line">	pt.push_back(&#123;x,y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">sort(pt.begin(),pt.end(),[](<span class="keyword">const</span> P&amp; a, <span class="keyword">const</span> P&amp; b)&#123;</span><br><span class="line">	<span class="keyword">return</span> a.X&lt;b.X||(a.X==b.X&amp;&amp;a.Y&lt;b.Y);</span><br><span class="line">&#125;);</span><br><span class="line">P p1=pt[<span class="number">0</span>], p2=pt.back();</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; up, down;</span><br><span class="line">up.push_back(p1); down.push_back(p1);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;pt.size();i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(i==pt.size()<span class="number">-1</span>||(conj(pt[i]-p1)*(p2-pt[i])).Y&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(up.size()&gt;=<span class="number">2</span>&amp;&amp;(conj(up[up.size()<span class="number">-1</span>]-up[up.size()<span class="number">-2</span>])*(pt[i]-up[up.size()<span class="number">-1</span>])).Y&lt;=<span class="number">0</span>)</span><br><span class="line">			up.pop_back();</span><br><span class="line">		up.push_back(pt[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(i==pt.size()<span class="number">-1</span>||(conj(pt[i]-p1)*(p2-pt[i])).Y&lt;<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">while</span>(down.size()&gt;=<span class="number">2</span>&amp;&amp;(conj(down[down.size()<span class="number">-1</span>]-down[down.size()<span class="number">-2</span>])*(pt[i]-down[down.size()<span class="number">-1</span>])).Y&gt;=<span class="number">0</span>)</span><br><span class="line">			down.pop_back();</span><br><span class="line">		down.push_back(pt[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;P&gt; result;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;up.size();i++)</span><br><span class="line">	result.push_back(up[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=down.size()<span class="number">-2</span>;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">	result.push_back(down[i]);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;result.size()&lt;&lt;<span class="string">"\n"</span>;</span><br></pre></td></tr></table></figure>
<h2 id="Rotating-Calipers"><a href="#Rotating-Calipers" class="headerlink" title="Rotating Calipers"></a>Rotating Calipers</h2><p>Convex Hull을 구하고 $O(N)$만에 거리가 가장 먼 점을 찾는 기법</p>
<p>주의: Convex hull이 시계방향으로 정렬되어있어야 사용할 수 있음, 반시계방향으로 정렬 되어 있다면 4행의 while문의 cw함수 호출을 ccw로 고칠 것</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// distance function</span></span><br><span class="line"><span class="function">ll <span class="title">dis</span><span class="params">(P a, P b)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a.X-b.X)*(a.X-b.X)+(a.Y-b.Y)*(a.Y-b.Y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;P,P&gt; ans; ll mxdis=<span class="number">0</span>;</span><br><span class="line">ll j=<span class="number">1</span>; <span class="keyword">int</span> chs=ch.size();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;chs;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(cw(ch[i],ch[(i+<span class="number">1</span>)%chs],ch[(i+<span class="number">1</span>)%chs]+(ch[(j+<span class="number">1</span>)%chs]-ch[j%chs])))&#123;</span><br><span class="line">		<span class="keyword">if</span>(mxdis&lt;dis(ch[i],ch[j%chs]))&#123;</span><br><span class="line">			mxdis=dis(ch[i],ch[j%chs]);</span><br><span class="line">			ans=&#123;ch[i],ch[j%chs]&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">		j++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(mxdis&lt;dis(ch[i],ch[j%chs]))&#123;</span><br><span class="line">		mxdis=dis(ch[i],ch[j%chs]);</span><br><span class="line">		ans=&#123;ch[i],ch[j%chs]&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/USACO%202021%20February%20Contest%20(Silver)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/USACO%202021%20February%20Contest%20(Silver)/" class="post-title-link" itemprop="url">USACO 2021 February Contest (Silver)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2021-03-23 18:48:05" itemprop="dateCreated datePublished" datetime="2021-03-23T18:48:05+09:00">2021-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2021-04-27 18:30:07" itemprop="dateModified" datetime="2021-04-27T18:30:07+09:00">2021-04-27</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Comfortable-Cows"><a href="#Comfortable-Cows" class="headerlink" title="Comfortable Cows"></a>Comfortable Cows</h2><p><a href="https://www.acmicpc.net/problem/21232" target="_blank" rel="noopener">BOJ#21232</a></p>
<p>각 iteration 마다 cow를 추가하게 되면, 추가한 cell과, 인접한 cell간의 상태에 변화가 일어난다. 크게 두가지 상황이 있다.</p>
<ul>
<li>cow를 추가한 cell에는 원래 인접한 cow가 3개였는데, 정작 해당 칸에는 cow가 점유하고 있지 않은 상태여서 나머지 cell에 cow가 점유하고 있지 않아도 됐지만, 이번 iteration에서 해당 cell에 cow를 추가하여서 나머지 cell도 cow를 추가해야하는 상황</li>
<li>cow를 추가한 cell과 인접한 4개의 cell은, 이번 iteration에 cow가 추가되면서 인접한 cow의 수가 1늘어나 3이되어 나머지 cell에 cow를 추가해야하는 상황</li>
</ul>
<p>매 iteration 마다 추가해야하는 cow를 계산하려고 하지말고 변화에 집중해서 문제를 관찰해보자.  잘 생각해보면, 추가해야되는 것으로 판단되었던 cell이 다시 추가하지 않아도 되는 cell로 돌아가는 경우는 없다. 다시 말하면, 한번 cow를 추가하기로 되어 있었다면, 모든 iteration이 끝날때 까지 그 상태가 유지가 된다. 따라서 매 iteration 마다 추가해야하는 cow를 계산하려고 하지말고 매 iteration마다 나타나는 상태 변화에 집중해서 문제를 관찰해보자. 어떤 cell에 cow를 추가해야하지만 추가되지 않은 cell도 그냥 그 cell은 점유되었다고 생각하면 편하다. 그리고 점유된(실제로 cow가 점유하고 있거나 점유되어야 하는 칸 모두) cell 갯수에서 실제로 cow가 점유하고 있는 cell의 갯수를 매 iteration마다 출력해주면 된다. 추가해야하는 cow는 각 iteration별로 dfs를 해주면 구할 수 있다.</p>
<h2 id="Year-of-the-Cow"><a href="#Year-of-the-Cow" class="headerlink" title="Year of the Cow"></a>Year of the Cow</h2><p><a href="https://www.acmicpc.net/problem/21233" target="_blank" rel="noopener">BOJ#21233</a></p>
<p>입력받은 시간들을 정렬하고, 그것을 각각 $t_0, t_1, \cdots, t_{N-1}$이라고 하자. ($t_0$이 가장 먼 과거이다.) 그리고 시간이 과거에서 현재로 흐른다는 이점을 최대한 활용하기 위해, 현재에서 $t_0$에 위치한 ancestor를 만나기 위한 과거로 portal을 한번 이용한다. ($ceil()$을 이용하면 편할 것이다.) 이제 해야할 것은, $t_i$와 $t_j$사이에 portal을 사용하면 어떤지를 평가하는 것이다. 정확히는  $t_i$에 위치한 ancestor를 만난 후, portal을 사용해서 $t_j$에 위치한 ancestor를 만나기 위한 시간의 최대값으로 이동하는 것이다. 마찬가지로 $ceil()$, $floor()$등을 계산하면 쉽게 계산을 할 수 있다. portal을 이용해서 절약할 수 있는 시간을 $timegap$에 모아서 정렬을 해준다. 가장 큰것부터 $min(timegap_{size},K-1)$개 뽑아서 처음 portal을 사용하여 돌아간 시간에서 빼주면 된다. </p>
<h2 id="Just-Green-Enough"><a href="#Just-Green-Enough" class="headerlink" title="Just Green Enough"></a>Just Green Enough</h2><p><a href="https://www.acmicpc.net/problem/21234" target="_blank" rel="noopener">BOJ#21234</a></p>
<p>문제를 단순화시켜서, sub-grid의 최소 green-ness가 100인 경우에서 101인 경우를 빼는 것으로 이 문제의 정답인 최소 green-ness가 정확히 100인 경우의 가짓수를 세도록 하자. 그렇다면 해결해야할 문제는 최소 green-ness가 $m$일 때, sub-grid의 가짓수를 시간내에 해결해야 한다.</p>
<p>우선 Naive하게 생각해보자. sub-grid는 모두 $N^2(N+1)^2/4$가지 경우가 있다고 한다. 각 sub-grid 마다 문제에서 주어진 sufficiently green한 조건을 만족하는지 확인하는데 $O(1)$이 걸린다고 쳐도, 이 방법으로는 $O(N^4)$의 시간이 걸리기 때문에 TLE를 면치 못할 것이다.</p>
<p>축 하나를 정하고, 해당 축에서 sub-grid의 시작지점과 끝지점을 각각 $i$, $j$로 고정하겠다. 문제를 1차원으로 축소해서 생각해보면, $O(N)$에 해결할 수 있다. 이를 prefix sum을 사용하여 저장해두면, 해당 행의 $i$~$j$까지의 cell이 모두 green-ness가 $m$보다는 같거나 큰것인지 $O(1)$에 알 수 있다. $k$행에서 $i$~$j$번째 cell의 green-ness가 모두 $m$보다 큰지를 $g_{i,j}(k)$라고 나타내도록 하자. 그렇다면 모든 $0\leq k&lt;N$을 만족하는 모든 $k$에 대해서 $g_{i,j}(k)$를 계산할 수 있다. $g_{i,j}(k)$가 참인 $k$에 대해서 아까와 비슷한 상황이 나오게 되는데, $i$, $j$를 한축의 끝과 끝 좌표로 가지는 모든 sub-grid의 개수를 $O(N)$에 계산할 수 있게 된다. 그렇다면 문제를 $O(N^3)$에 해결할 수 있다. 실제로는 $_NC_2*N$번의 iteration을 수행하므로 단순 $O(N^3)$보다는 2배정도 빠르다.</p>
<p>iteration 순서를 조금 변형시켜서 $O(N^2)$에 문제를 해결하는 흥미로운 방법도 있다고 한다. <a href="http://usaco.org/current/data/sol_prob3_silver_feb21.html" target="_blank" rel="noopener">http://usaco.org/current/data/sol_prob3_silver_feb21.html</a> 를 참조하자.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/bitmask-hacks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/bitmask-hacks/" class="post-title-link" itemprop="url">비트마스크(BitMask) 고급 테크닉</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-08-20 00:33:05 / Updated at: 01:08:30" itemprop="dateCreated datePublished" datetime="2020-08-20T00:33:05+09:00">2020-08-20</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p>여기서는 비트마스크를 이용한 문제를 해결할때 사용가능한 몇가지 유용한 고급 테크닉을 소개합니다.<br>&lt;프로그래밍 대회에서 배우는 알고리즘 문제 해결 전략 (구종만저)&gt; 의 내용을 참고함을 밝힙니다.</p>
<h2 id="집합-크기-연산"><a href="#집합-크기-연산" class="headerlink" title="집합 크기 연산"></a>집합 크기 연산</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__builtin_popcount(<span class="built_in">bitset</span>);</span><br></pre></td></tr></table></figure>
<p>gcc/g++ 환경에서 켜져있는 비트의 수를 반환합니다. 이 포스트에서 소개되는 내장 명령어는 컴파일러 의존적이기 때문에, 특정환경에서 사용이 불가능할 수 있습니다. 따라서 이를 직접 구현해보면 다음과 같습니다.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">popcount</span><span class="params">(<span class="keyword">int</span> <span class="built_in">bitset</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bitset</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> x % <span class="number">2</span> + bitcount(x / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>각 비트를 재귀적으로 모두 탐색해준 방법입니다. 빌트인함수를 사용할 수 없을 떄 사용해보세요.</p>
<h2 id="최소-원소-탐색"><a href="#최소-원소-탐색" class="headerlink" title="최소 원소 탐색"></a>최소 원소 탐색</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__bulitin_ctz(<span class="built_in">bitset</span>);</span><br></pre></td></tr></table></figure>
<p>gcc/g++ 환경에서 켜져있는 최하위 비트의 인덱스를 반환합니다. 이 함수를 사용할 떄, 주의해야할 점은 입력이 0일때는 결과가 정의가 되어있지 않기때문에, 꼭 Bitset이 0인지 확인해야 합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> firstbit = (<span class="built_in">bitset</span> &amp; -<span class="built_in">bitset</span>);</span><br></pre></td></tr></table></figure>
<p>이 방법은 비트의 인덱스가 아닌 해당 비트의 값자체를 반환합니다. 2의 보수의 성질을 이용한 테크닉입니다.</p>
<h2 id="최소-원소-삭제"><a href="#최소-원소-삭제" class="headerlink" title="최소 원소 삭제"></a>최소 원소 삭제</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bitset</span> &amp;= (<span class="built_in">bitset</span> - <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>켜져있는 최하위 비트를 삭제하는 테크닉입니다. 이 역시 위에 소개된 비트의 값을 구할 때 사용된 2의 보수의 성질을 이용한 것입니다.</p>
<h2 id="참고하면-좋은-사이트들"><a href="#참고하면-좋은-사이트들" class="headerlink" title="참고하면 좋은 사이트들"></a>참고하면 좋은 사이트들</h2><ol>
<li><a href="http://graphics.stanford.edu/~seander/bithacks.html" target="_blank" rel="noopener">http://graphics.stanford.edu/~seander/bithacks.html</a></li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/how-to-bitmask/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/how-to-bitmask/" class="post-title-link" itemprop="url">비트마스크(BitMask) 사용해보기</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>
              

              <time title="Post created: 2020-08-19 17:44:23 / Updated at: 18:39:00" itemprop="dateCreated datePublished" datetime="2020-08-19T17:44:23+09:00">2020-08-19</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p> 문제해결을 할때, 우리는 int나 float 형과 같이 우리 인간에게 가장 익숙한 수체계인 십진수로 표현할 수 있는 수들을 사용하여 각종 문제를 해결해왔습니다. 하지만 현대의 대부분의 컴퓨터는 이진수를 사용하여 데이터를 나타내거나 연산을 합니다. 따라서 내부적으로 다시 이진수로 변환되어 연산되는 십진수 연산보다 처음부터 이진수로 연산되는 연산이 더 빠를 것이라고 짐작할 수 있습니다.</p>
<h2 id="비트마스크란"><a href="#비트마스크란" class="headerlink" title="비트마스크란?"></a>비트마스크란?</h2><p> 앞서 말한 이진수 연산의 장점을 최대한 활용하기 위해 고안된, 정수의 이진수 표현을 활용한 기법이 바로 비트마스크(BitMask)입니다. 다음 예시문제를 생각해 봅시다.</p>
<blockquote>
<p>$0$ 번부터 $N-1$ 번까지 번호가 붙어있는 전구의 상태는 총 몇가지로 표현될 수 있을까?</p>
</blockquote>
<p> 전구는 그럼 총 $N$ 개가 있고, 각 전구는 켜졌거나 꺼졌거나의 두가지 상태를 나타낼 수 있기 때문에 $2^N$ 가지의 상태가 있다고 생각할 수 있습니다. 이 상태를 각 $0$부터 $2^N-1$까지, 총 $2^N$ 가지의 정수에 일대일 대응을 하는겁니다.</p>
<p> $N=4$라고 생각하겠습니다. 모든 전구가 다 꺼졌을때는, 0000 즉, 십진수로 표현하면 0이라는 상태로 나타낼 수 있습니다. 만약 모든 전구가 다 켜졌을때는 어떻게 될까요? 1111 즉, 십진수로 표현했을 때, 15가 됩니다. 만약 x번째 전구가 켜졌을때는, 상태번호를 이진수로 표현했을때 그 수의 x번째 수를 1, 꺼졌을때는 0으로 표현합니다. 말이 좀 복잡했네요, 마지막으로 한가지 예시를 들면 0번째 전구와 3번째 전구가 켜진 상태는 1001, 즉 상태를 십진수 9로 나타낼 수 있는 것입니다. </p>
<h2 id="비트마스크를-사용하면-좋은점"><a href="#비트마스크를-사용하면-좋은점" class="headerlink" title="비트마스크를 사용하면 좋은점"></a>비트마스크를 사용하면 좋은점</h2><p> 예시를 들다보니, 조금 더 쉽게 설명하고 싶은 욕심에 글이 길어졌네요. 말로만 들으면 이렇게 복잡한 비트마스크를 도대체 왜 사용해야할까요? 대표적으로 <strong>TSP(Travelling Salesman Problem, 외판원순회문제)</strong>에서 비트마스킹이 유용하게 사용될 수 있습니다. 메모리제한이 빡빡한 문제에서 어떤 집합을 표현할때 비트마스킹이 다른 집합 표현방법보다 메모리를 덜 사용하는 장점이 있습니다. 앞서 말했듯, N개의 원소로 이루어진 집합의 부분집합을 단 N개의 비트만 사용해서 나타낼 수 있으니까요. 그리고 대부분의 비트마스크 연산은 $O(1)$의 시간복잡도를 가지기 때문에, 시간적인 면에서 약간의 이득을 볼 가능성도 있습니다.</p>
<h2 id="비트마스크-사용법-C"><a href="#비트마스크-사용법-C" class="headerlink" title="비트마스크 사용법(C++)"></a>비트마스크 사용법(C++)</h2><p> 그래서 비트마스크 그리고 비트마스크와 관련된 연산은 어떻게 구현해야할까요? 이 문단에서는 C++을 이용해 비트마스크를 사용할 수 있는 방법을 알려드립니다.</p>
<h3 id="집합표현"><a href="#집합표현" class="headerlink" title="집합표현"></a>집합표현</h3><p> 자 우선 비트마스크를 하기 위해서는 집합의 상태를 표현할 수 있는 숫자가 있어야합니다.<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> status = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><br> 집합의 상태를 표현하는 변수인 status를 만들었습니다. 이 집합은 현재 모든 비트가 꺼져있습니다. 앞으로 공집합을 나타내고 싶을때는, 해당 변수를 0으로 초기화해주세요. 이 집합은 원소가 10개 인것으로 약속합시다.</p>
<p> 공집합과 반대로, 집합의 원소 10개 모두 존재하는 것으로 나타내고 싶으면 어떻게 해야할까요?<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status = (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><br> &lt;&lt; 연산자는, 현재 변수에서 원하는 만큼 비트를 왼쪽으로 미는 연산자입니다. 예시에서는 1이라는 수를 왼쪽으로 10번 밀고 1을 뺀 수를 나타내고 있네요, 이진수 10000000000 에서 1을 빼면 어떻게 되나요? 1111111111이 되겠죠? 그러면 우리가 원하는대로 10개의 비트 모두 켜진 상태가 됩니다.</p>
<h3 id="원소-포함-여부-확인"><a href="#원소-포함-여부-확인" class="headerlink" title="원소 포함 여부 확인"></a>원소 포함 여부 확인</h3><p> 만약에 x번째 전구가 켜져있는지 확인하려면 어떻게 해야할까요?<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(status &amp; (<span class="number">1</span> &lt;&lt; x))&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> 소스코드를 이해해봅시다. 여기서 나오는 &amp; 연산은 우리가 알고있는 AND 논리연산과 같습니다. 같은자리수 비트를 비교할 때, 두 비트 모두 켜져있어야 1을 반환하고 그렇지 않으면 0을 반환하는 연산자입니다. 1 &lt;&lt; x 는 x번째 비트만 켜진, 우리가 만든 수입니다. 그 수와 status와 AND연산을 하고있네요. 만약 status의 x번째 비트가 1이라면 if절안의 내용이 참이되고, x번째 비트가 0이라면 if절 안의 내용이 거짓이 되겠죠. 이해가 안되시면 천천히 다시 읽어보면서 제대로 이해하고 넘어가주세요.</p>
<h3 id="원소-추가와-삭제"><a href="#원소-추가와-삭제" class="headerlink" title="원소 추가와 삭제"></a>원소 추가와 삭제</h3><p> 자, 집합의 상태는 문제에 따라 변할수도, 아닐수도 있습니다. 이 절에서는 집합의 상태가 변하는 경우를 살펴보죠. </p>
<p> 우선 원소를 추가해보고 싶습니다. 앞의 예시의 표현대로라면, 특정한 전구를 켜고싶습니다. 어떻게 해야할까요? 다음 예시는 x번째 비트를 켜는 소스코드입니다.<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status |= (<span class="number">1</span> &lt;&lt; x);</span><br></pre></td></tr></table></figure><br> 여기서 |는 OR연산입니다. 그러니까 다음과 같은 표현의 축약형입니다.<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status = status | (<span class="number">1</span> &lt;&lt; x);</span><br></pre></td></tr></table></figure><br> x번째 비트가 이미 켜져있으면 유지하고, 꺼져있으면 켜지겠네요. 따라서 원소가 추가된것과 같은 효과라고 말할 수 있겠습니다.</p>
<p> 그 다음은 원소를 삭제해볼 차례입니다.<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status &amp;= ~(<span class="number">1</span> &lt;&lt; x);</span><br></pre></td></tr></table></figure><br> 참고로, ~는 NOT연산입니다. 그러니까 위의 예시는 ~(1 &lt;&lt; x)는 x번째 비트 빼고 모두 켜진 수겠네요. AND연산을 해보면 x번째 비트가 꺼져있으면 꺼져있는대로 유지하고, 켜져있으면 그 비트를 끄는 동작을 하니까 결과적으로 x번째 비트가 꺼지는 결과를 만들겠네요. 음… 조금 복잡하네요. 왜 이런 표현을 해야했을까요? 다음 예시를 보면서 이해해봅시다.<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">status -= (<span class="number">1</span> &lt;&lt; x);</span><br></pre></td></tr></table></figure><br> 이런식으로 표현을 하면, x번째 비트가 켜져있지 않을때 위와 같은 연산을 하면 의도치 않은 결과가 나올 수 있기 때문입니다. if문을 한줄 써서 해당 원소가 있는지 체크를 해준다면 위와 같은 표현을 써도 되지만, 보통 처음 소개해드린 방법 한줄로 끝내는 방법을 많이 선호합니다. 처음 소개해드린 방법은 x번째 비트가 꺼져있어도 의도치않은 결과를 초래하지 않습니다. 그리고 if문 없이 한줄로 끝낼 수 있다는 장점이 있죠!</p>
<h2 id="끝내며"><a href="#끝내며" class="headerlink" title="끝내며"></a>끝내며</h2><p> 우리는 십진수 수체계에 익숙해져있어서, 이진수 연산을 많이 접해볼 기회가 없었죠, 문제해결할때 우리는 십진수로 추상화된 자료형들을 많이 사용하고, 큰 불편함이 없었지만 앞으로는 이런 이진수 연산의 장점을 잘 사용해야 풀수있는 문제들이 많이 접하게될 것입니다. 비트마스킹과 비트마스킹에 사용되는 연산들의 논리를 잘 이해하시고 확실히 내 것으로 만들어 PS에 있어서 비트마스킹을 본인이 가진 하나의 “툴”로 잘 사용해보시기 바랍니다.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/proof-FIT/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/proof-FIT/" class="post-title-link" itemprop="url">페르마의 소정리 증명</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2020-07-28 11:02:48" itemprop="dateCreated datePublished" datetime="2020-07-28T11:02:48+09:00">2020-07-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-12-01 13:27:47" itemprop="dateModified" datetime="2020-12-01T13:27:47+09:00">2020-12-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h2><p><strong>페르마의 소정리(Fermat’s little Theorem, FlT)</strong>는 정수론의 근간이 되는 매우 중요한 정리입니다. 페르마의 소정리는 다음과 같습니다.</p>
<blockquote>
<p>$p$가 소수이고, $gcd(n, p) = 1$ 이면, $n^{p-1} \equiv 1 (mod\;p)$</p>
</blockquote>
<p>쉽게 풀어 설명하면 임의의 소수인 p와, p와 서로소인 수 n의 p-1승을 p로 나눈 나머지는 1이라는 뜻입니다.</p>
<p>PS를 하면서도 상당히 많이 사용하게 되는 정리이므로 증명이 필요하다고 생각 되어, 친구의 도움을 받아 증명을 하게 되었습니다.</p>
<h2 id="페르마의-소정리-증명"><a href="#페르마의-소정리-증명" class="headerlink" title="페르마의 소정리 증명"></a>페르마의 소정리 증명</h2><p>페르마의 소정리에 나오는 정의에 따라 p를 어떤 소수, a를 p와 서로소인 수로 두겠습니다. $\mathbb {Z}$는 정수집합입니다. 집합 $S=\{n|n \neq 0, n = \mathbb {Z}\,mod\;p\}$ 는 그럼 $p-1$개의 원소를 가지게 됩니다. 집합 $aS=\{n|n \neq 0, n = a ⋅ (\mathbb {Z}\,mod\;p)\}$ 는, 집합 $S$에 있는 모든 원소에 a를 곱한 원소로 이루어져있는 집합으로, 역시 $p-1$개의 원소를 가지게 됩니다.</p>
<p>집합 aS를 봅시다.</p>
<script type="math/tex; mode=display">\{a⋅1, a⋅2, ⋯, a⋅(p-1)\}</script><p>이 집합에 $(mod\;p)$ 연산을 해주면 놀랍게도 집합 S와 원소가 일치함을 보일 수 있습니다. p가 소수이고, a와 서로소이기 때문입니다. 따라서 $(mod\;p)$에서 다음과 같습니다.</p>
<script type="math/tex; mode=display">\{a⋅1, a⋅2, ⋯, a⋅(p-1)\} = \{1, 2, ⋯, (p-1)\}</script><p>그렇다면 집합 S의 원소들을 모두 곱한 값 $(p-1)!$과 집합 aS의 모든 원소들을 곱한 값 $a^{p-1}⋅(p-1)!$은 $(mod\;p)$에서 합동이며 수식으로 표현하면 다음과 같습니다.</p>
<script type="math/tex; mode=display">a^{p-1}⋅(p-1)! \equiv (p-1)! ⋅ (mod\;p)</script><p>여기서 나머지 연산은 분배법칙이 성립하므로 $(p-1)!$을 소거 하면 다음과 같은 결과를 얻을 수 있습니다.</p>
<script type="math/tex; mode=display">a^{p-1} \equiv 1 (mod\;p)</script><p>Q.E.D.!</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/my-first-codeforces-contest/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/my-first-codeforces-contest/" class="post-title-link" itemprop="url">Codeforces(코드포스) 첫 도전 후기</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 2019-11-25 21:57:00" itemprop="dateCreated datePublished" datetime="2019-11-25T21:57:00+09:00">2019-11-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2020-07-20 11:22:34" itemprop="dateModified" datetime="2020-07-20T11:22:34+09:00">2020-07-20</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="시작하기에-앞서…"><a href="#시작하기에-앞서…" class="headerlink" title="시작하기에 앞서…"></a>시작하기에 앞서…</h2><p> 저는 소프트웨어학과를 올해(2019) 입학한 신입생입니다. 저는 이중에서도 문제를 읽고, 그 문제를 조건에 맞춰 푸는 프로그램을 작성하는 분야인 PS(Problem Solving)에 관심이 많았습니다. 이 PS를 배우는 과정에서 커뮤니티나 동기, 선배 등 제가 가야 할 길을 미리 거쳐간 많은 사람들의 조언을 들을 수 있었는데, 그들이 입을 모아 말하는 것이 한 가지가 있습니다.</p>
<blockquote>
<p>문제를 많이 풀어봐라!</p>
</blockquote>
<p> 고등학생때 얕게 공부했던 경험으로 수학이나 물리와 같은 학문에도 적용되던 불변의 진리이지만, <strong>학문에 있어서 그 법칙과 개념들은 객관적인 것들입니다. 그러한 것들은 우리가 공부를 통해 받아들일 수 있습니다. 하지만 그러한 법칙과 개념들을 응용하는 것은 그저 그것을 알게 되는 것과는 전혀 다른 차원의 문제</strong>입니다.</p>
<p> 여기서 선배들이 해주신 조언이 빛을 발합니다. 바로 문제를 푸는것입니다. 반복된 훈련으로 무의식적으로 더 빠르고, 더 우아한 프로그래밍을 하기 위한 ‘직관’을 쌓아가게 됩니다.</p>
<p> 직관은 사실 매우 추상적인 개념인데, 굳이 말로 표현하자면 문제를 분석하는 능력과, 비슷한 상황에서 이전의 경험을 바탕으로 문제를 해결할 수 있는 능력 등을 말하는 것일 것입니다. 그리고 대부분의 학문에서 그렇듯이 <strong>문제해결에서 이 직관은 곧 실력을 의미</strong>합니다. 굳이 직관이 무엇인지 복잡하게 말로 풀지 않아도 여러분들도 문제 풀이가 단순히 문제를 푸는 그 이상의 의미를 가진다는 것을 잘 아실것이라 믿습니다.</p>
<h2 id="Codeforces를-만나다"><a href="#Codeforces를-만나다" class="headerlink" title="Codeforces를 만나다"></a>Codeforces를 만나다</h2><p> 그래서 저는 문제 해결을 연습하기 위해 유명한 온라인 저지 서비스인 <a href="https://www.acmicpc.net" target="_blank" rel="noopener">백준 온라인 저지</a>에서 기초적인 문제부터 문제를 풀기 시작했습니다. 아직 제대로된 알고리즘 아는 것 하나 없는 볼품없는 실력이지만, 한 문제 한 문제 풀어나갈 때마다 랭킹이 오르는 것을 보고 희열을 느낄 수 있었습니다. 문제 수로 사이트 이용자들과 경쟁이 아닌 경쟁을 한 것이지요.</p>
<p> 그리고 특히 제가 경쟁적인 상황에 놓였을때 얼마나 학습에 있어서 동기부여가 잘 되는지 온라인 저지를 사용 하면서 잘 알게 되었습니다. 더욱 더 경쟁적인 문제 해결 플랫폼을 찾던 도중, <a href="https://codeforces.com/" target="_blank" rel="noopener">Codeforces</a>라는 ps대회가 자주, 정기적으로 열리는 사이트를 발견하게 되었습니다.</p>
<p> 이 사이트는 열리는 Contest마다 사용자의 점수를 바탕으로 League of Legends 같은 게임처럼 참가자의 대략적인 실력을 나타내기 위한 rating을 매깁니다. 그리고 사용자에게 rating에 따른 닉네임 색상과 칭호를 부여합니다. 프로그래밍의 실력에 따라서 본인의 프로필에 가시적인 변화가 보이는 것이죠. 이 것을 보고 코드 포스는 제가 스스로 공부하도록 동기부여를 하게 만들 수 있는 최고의 매체라고 생각하였습니다.</p>
<h2 id="첫-Contest-결과"><a href="#첫-Contest-결과" class="headerlink" title="첫 Contest 결과"></a>첫 Contest 결과</h2><p> 그렇게 하여 첫 Contest로 <a href="https://codeforces.com/contest/1262" target="_blank" rel="noopener">Codeforces Round #602 (Div. 2, based on Technocup 2020 Elimination Round 3)</a>에 참가하여 문제를 풀어보았습니다. 경쟁적 프로그래밍에 처음 참가해본 저로써는 다소 이해하기 어려운 점수 시스템이 있었는데, 이것은 다음에 제가 더 경험이 많이 쌓인다면 포스팅해보겠습니다. (문제풀이뿐만 아니라 Hack이라는 행위를 통해서도 점수를 획득할 수 있는 등의 복잡한 규칙이 있습니다)</p>
<p> 그렇게 해서 받은 저의 첫번째 성적입니다.<br><img src="https://blog.kakaocdn.net/dn/cZxpRr/btqzYUTOAQR/nDIbVad61Ze4KQskyGXHBK/img.png" alt="score_table"></p>
<p> 총 8개의 문제가 있는데, 그 중 가장 쉬운 문제인 A번을 대회 시작 후 50분이 지난 시간에 풀었습니다. 그리고 곧바로 B번을 도전하였는데, A번과는 살짝 괴리가 있는 난이도를 가진 문제였습니다. 표를 보시면 B에 -1이라는 기록이 되어있는데, 이는 제가 한 번의 제출을 실패했다는 뜻입니다. 이 제출에서 첫 번째 테스트 케이스는 통과하였지만 두 번째 테스트 케이스는 통과하지 못하였습니다. 제가 완벽하지 않은 코드를 시험 삼아(…) 제출해본 것이 그 이유입니다. 결국 A, B번을 푸는데 시간을 너무 많이 할애하여 저의 실력으로는 C번부터는 문제를 읽어보지도 못했습니다. 저의 실력에 반성을 하게 만드는 성적이였습니다.</p>
<p><img src="https://blog.kakaocdn.net/dn/cwVAJa/btqzYU7ffbE/SH8KrEeEndJOs4kADALvck/img.png" alt="rating_graph"></p>
<h2 id="느낀점"><a href="#느낀점" class="headerlink" title="느낀점"></a>느낀점</h2><p> 그리고 대회 종료후 얼마 뒤 제 프로필을 가보니 텅텅 비어있던 Rating graph에 점 하나가 찍혀있었습니다. 바로 제가 참가했던 첫 코드 포스 라운드에서 배정받은 rating이었습니다. 1415점, Specialist등급 이네요! A번만 풀고 전문가 칭호를 받다니 좀 양심에 가책을 느끼네요. 이름뿐인 건 알지만 앞으론 더 열심히 하라는 Codeforces의 깊은 뜻이 아닐까 싶습니다. <del>실상은 이름만 Specialist일 뿐이지 민딱이라는 귀여운 칭호를 가지고 있습니다.</del></p>
<p> 저는 정말 최근에야 PS를 시작했습니다. 사실 어디가서 PS좀 해봤다고 말할 실력도 아닙니다. 아직 조건문, 반복문만 사용한 구현만 조금 하는 수준이고, 앞으로 더 배워야 할 부분이 정말 많은 것을 알고 있습니다. (특히 이번 Contest에서 한 문제밖에 못 푼 것으로 이 것을 더 절실히 느낍니다)</p>
<p> 당장은 미래에 더 높은 연봉같은 거창한 목표를 위해 PS를 하는 것이 아니라, 코드 포스 닉네임 색깔을 더 화려한 색깔로 바꾸기 위해 공부할 것입니다. 일단 세 달 안에 파란색 등급을 달성해 보는 것이 저의 목표입니다. 엄청 유치한 이유긴하지만, 어쨌든 방구석백수처럼 사는것 보단 낫잖아요?</p>
<p> 앞으로도 주기적으로 Codeforces를 비롯한 대회 참가 수기를 많이 남기겠습니다. 저의 발전을 기대해 주세요. :^)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="ko">
    <link itemprop="mainEntityOfPage" href="https://sylvesterkwon.github.io/test-post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Dohyun Kwon">
      <meta itemprop="description" content="Computer Science / Problem Solving / Competitive Programming">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ASIX' AXIS">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/test-post/" class="post-title-link" itemprop="url">테스트 포스트</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">작성일</span>

              <time title="Post created: 1970-01-01 00:00:00" itemprop="dateCreated datePublished" datetime="1970-01-01T00:00:00+09:00">1970-01-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Updated at: 2021-06-23 19:26:17" itemprop="dateModified" datetime="2021-06-23T19:26:17+09:00">2021-06-23</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>이 포스트는 테스트용으로 작성되었습니다.</p>
<h1 id="제목1"><a href="#제목1" class="headerlink" title="제목1"></a>제목1</h1><h2 id="제목2"><a href="#제목2" class="headerlink" title="제목2"></a>제목2</h2><h3 id="제목3"><a href="#제목3" class="headerlink" title="제목3"></a>제목3</h3><h4 id="제목4"><a href="#제목4" class="headerlink" title="제목4"></a>제목4</h4><h5 id="제목5"><a href="#제목5" class="headerlink" title="제목5"></a>제목5</h5><h6 id="제목6"><a href="#제목6" class="headerlink" title="제목6"></a>제목6</h6><ol>
<li>목록1<ul>
<li>서브목록1</li>
<li>서브목록2</li>
</ul>
</li>
<li>목록2<ul>
<li>서브목록1</li>
<li>서브목록2</li>
</ul>
</li>
</ol>
<ul>
<li>순서없는목록<ul>
<li>작은순서없는목록</li>
</ul>
</li>
</ul>
<p><em>EXCELSIOR! 이텔릭체는 별표!</em><br><strong>볼드체는 별표 두개!</strong><br><del>취소선은 물결표시로!</del><br><u>밑줄은 u태그로!</u><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">"Hello world!\n"</span>;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>인용1</p>
<blockquote>
<p>인용2</p>
</blockquote>
</blockquote>
<script type="math/tex; mode=display">x = \frac{-b \pm \sqrt{b^2-4ac}}{2a}</script><p>$ x = \frac{-b \pm \sqrt{b^2-4ac}}{2a} $</p>
<script type="math/tex; mode=display">
\begin{pmatrix}
 1 & a_1 & a_1^2 & \cdots & a_1^n \\
 1 & a_2 & a_2^2 & \cdots & a_2^n \\
 \vdots  & \vdots& \vdots & \ddots & \vdots \\
 1 & a_m & a_m^2 & \cdots & a_m^n    
 \end{pmatrix}</script><script type="math/tex; mode=display">\begin{align*} 
a & = b q_1 + r_1 \\
b & = r_1 q_2 + r_2 \\ 
& \vdots \\
r_{n - 1} & = r_n q_n + r_{n + 1} \\
r_{n + 1} & = 0 
\end{align*}</script><p>hexo framework는 죄가 없다. - 6/23/2021</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          목차
        </li>
        <li class="sidebar-nav-overview">
          흝어보기
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Dohyun Kwon</p>
  <div class="site-description" itemprop="description">Computer Science / Problem Solving / Competitive Programming</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">9</span>
          <span class="site-state-item-name">포스트</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">태그</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/SylvesterKwon" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;SylvesterKwon" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:asix71@gmail.com" title="E-Mail → mailto:asix71@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/ASIX_KWON" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;ASIX_KWON" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dohyun Kwon</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
